# -*- coding: utf-8 -*-
"""Projectwork15.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MqFM3q14VQ8zawt70-QMvEJ5yaCHLUFN
"""

"""
Tema n. 1: La digitalizzazione dell'impresa.
Traccia del PW 15. Sviluppo di un codice python per simulare un processo produttivo nel settore primario.
Corso di Laurea: L-31 Informatica per le Aziende Digitali.
Studentessa: [Tiziana Lo Vecchio]
MATRICOLA: [0312301360]

OBIETTIVI DELLA SIMULAZIONE:
Il seguente script Python funge da motore di simulazione per la pianificazione aziendale.
Attraverso l'uso di librerie di calcolo statistico, il software stima i volumi produttivi
e i carichi di lavoro (ore uomo/macchina) per le diverse Sequenze Produttive,
variando gli output in base a un coefficiente di stress idrico (scenario di crisi).
"""

# --- LIBRERIE DI SUPPORTO ---
import numpy as np   # Necessaria per le proiezioni statistiche (distribuzioni)
import pandas as pd  # Necessaria per l'organizzazione tabellare dei KPI

# =============================================================================
# 1. SETTING DEI PARAMETRI AZIENDALI E AMBIENTALI
# =============================================================================

# Coefficiente di Crisi Idrica (Dati Osservatorio Sicilia 2024/25)
# Scala da 0.0 (Nessuna siccità) a 1.0 (Perdita totale).
# Impostiamo 0.48 per simulare una condizione di scarsità severa.
COEFF_CRISI_IDRICA = 0.48

# --- CONFIGURAZIONE AGRUMI (Arancia Rossa) ---
AGRUMI_RESA_STANDARD = 27800.0      # Kg stimati per ettaro (Media storica)
AGRUMI_VARIANZA = 2400.0            # Deviazione standard (Oscillazione naturale)
# Throughput delle sequenze di lavorazione (Kg processati all'ora)
CAPACITA_LINEA_FRESCO = 1850.0      # Sequenza A: Selezione GDO (più lenta)
CAPACITA_LINEA_SUCCO = 4600.0       # Sequenza B: Spremitura (più veloce)

# --- CONFIGURAZIONE OLIVICOLTURA (Nocellara) ---
OLIVE_RESA_STANDARD = 7600.0        # Kg stimati per ettaro
OLIVE_VARIANZA = 850.0              # Deviazione standard
# Produttività oraria per sequenza di raccolta
KPI_RACCOLTA_MANUALE = 19.0         # Sequenza A: Kg/h per operatore
KPI_RACCOLTA_MECCANICA = 1350.0     # Sequenza B: Kg/h per macchina

# --- CONFIGURAZIONE PESCHE TARDIVE (Leonforte IGP) ---
DENSITA_IMPIANTO = 500              # Alberi per ettaro
MEDIA_FRUTTI_ALBERO = 375           # Carico pendente medio
SEC_INSACCHETTATURA = 12.0          # Sequenza A: Tempo operatore per 1 frutto

# =============================================================================
# 2. ARCHITETTURA DEL SOFTWARE (CLASSI E LOGICA)
# =============================================================================

class AnalisiClimatica:
    """
    Modulo statico per la valutazione del rischio meteo.
    Calcola il deprezzamento della produzione (Quantità e Qualità) in base
    alla sensibilità specifica della coltura.
    """
    @staticmethod
    def stima_danno_idrico(categoria_prodotto, volume_teorico):
        """
        Input: Tipo di prodotto e volume ideale.
        Output: Volume effettivo post-danno, Note operative, % di perdita.
        """
        coefficiente_vulnerabilita = 1.0
        messaggio_rischio = ""

        # Definizione della sensibilità biologica delle piante
        if categoria_prodotto == "Agrumi":
            coefficiente_vulnerabilita = 1.25  # Alta sensibilità: riduzione calibro frutto
            messaggio_rischio = "Calibro ridotto (Nanismo)"
        elif categoria_prodotto == "Olive":
            coefficiente_vulnerabilita = 0.75  # Media-Bassa: pianta resistente
            messaggio_rischio = "Disidratazione drupa"
        elif categoria_prodotto == "Pesche":
            coefficiente_vulnerabilita = 1.0   # Media sensibilità
            messaggio_rischio = "Rischio conformità IGP"

        # Calcolo del fattore di abbattimento (Clamping a 1.0)
        fattore_perdita = min(1.0, COEFF_CRISI_IDRICA * coefficiente_vulnerabilita)

        # Applicazione della perdita al volume stimato
        volume_reale = volume_teorico * (1.0 - fattore_perdita)

        return volume_reale, messaggio_rischio, fattore_perdita


class UnitaProduttiva:
    """
    Classe Astratta che definisce l'entità 'Campo Agricolo'.
    Fornisce la struttura dati base per le sottoclassi specifiche.
    """
    def __init__(self, codice_appezzamento, ettari_totali, tipologia):
        self.codice = codice_appezzamento
        self.ettari = ettari_totali
        self.tipologia = tipologia
        self.report_dati = {} # Dizionario per lo storage dei KPI finali

    def elabora_scenario(self):
        """Metodo placeholder, implementato nelle classi derivate."""
        pass


class ColturaAgrumi(UnitaProduttiva):
    """
    Gestione specifica per Arance.
    LOGICA DECISIONALE: Allocazione dinamica delle risorse tra Sequenza A e B
    in base alla qualità del prodotto influenzata dal clima.
    """
    def __init__(self, codice, ettari):
        super().__init__(codice, ettari, "Arance Tarocco")

    def elabora_scenario(self):
        # 1. Creazione dello scenario produttivo (Distribuzione Gaussiana)
        resa_base = np.random.normal(AGRUMI_RESA_STANDARD, AGRUMI_VARIANZA)
        totale_stimato = resa_base * self.ettari

        # 2. Valutazione impatto ambientale
        totale_netto, note_meteo, perdita_pct = AnalisiClimatica.stima_danno_idrico(self.tipologia, totale_stimato)

        # 3. Algoritmo di indirizzamento prodotto (Business Logic)
        # Se la siccità è alta, aumenta la percentuale destinata alla Sequenza B (Succo).
        percentuale_succo = 0.15 + (COEFF_CRISI_IDRICA * 0.65)
        percentuale_succo = min(0.95, percentuale_succo) # Tetto massimo 95%

        volume_industria = totale_netto * percentuale_succo
        volume_gdo = totale_netto - volume_industria

        # 4. Stima dei tempi di lavorazione (Process Mining)
        # Sequenza A: Linea Fresco
        h_seq_a = volume_gdo / CAPACITA_LINEA_FRESCO
        # Sequenza B: Linea Succo
        h_seq_b = volume_industria / CAPACITA_LINEA_SUCCO

        # 5. Compilazione Report
        self.report_dati = {
            "Codice_Lotto": self.codice,
            "Coltura": self.tipologia,
            "Input_Totale_Kg": round(totale_netto, 2),
            "Sequenza_A": "GDO (Fresco)",
            "Sequenza_B": "Industria (Succo)",
            "Output_A_Kg": round(volume_gdo, 2),
            "Output_B_Kg": round(volume_industria, 2),
            "Ore_Seq_A": round(h_seq_a, 2),
            "Ore_Seq_B": round(h_seq_b, 2),
            "Note_Operative": f"{note_meteo}. Split Succo: {round(percentuale_succo*100)}%"
        }
        return self.report_dati


class ColturaOlivicola(UnitaProduttiva):
    """
    Gestione specifica per Olive.
    LOGICA DECISIONALE: Analisi comparativa dei costi/tempi tra
    Sequenza A (Manuale) e Sequenza B (Meccanizzata).
    """
    def __init__(self, codice, ettari):
        super().__init__(codice, ettari, "Olive Nocellara")

    def elabora_scenario(self):
        # 1. Simulazione statistica della resa
        resa_base = np.random.normal(OLIVE_RESA_STANDARD, OLIVE_VARIANZA)
        totale_netto, note_meteo, _ = AnalisiClimatica.stima_danno_idrico(self.tipologia, resa_base * self.ettari)

        # 2. Sequenza A: Raccolta Manuale (Labor Intensive)
        # Ipotizziamo una squadra standard di 6 operatori
        num_operatori = 6
        h_seq_a = totale_netto / (KPI_RACCOLTA_MANUALE * num_operatori)

        # 3. Sequenza B: Raccolta Meccanizzata (Capital Intensive)
        # Consideriamo un fattore correttivo del 20% per i tempi di manovra
        h_seq_b = (totale_netto / KPI_RACCOLTA_MECCANICA) * 1.20

        self.report_dati = {
            "Codice_Lotto": self.codice,
            "Coltura": self.tipologia,
            "Input_Totale_Kg": round(totale_netto, 2),
            "Sequenza_A": "Manuale",
            "Sequenza_B": "Meccanizzata",
            "Output_A_Kg": round(totale_netto, 2), # L'output fisico è identico
            "Output_B_Kg": round(totale_netto, 2),
            "Ore_Seq_A": round(h_seq_a, 2),
            "Ore_Seq_B": round(h_seq_b, 2),
            "Note_Operative": f"Delta Efficienza: Seq. B {round(h_seq_a/h_seq_b, 1)}x più veloce"
        }
        return self.report_dati


class ColturaPescheTardive(UnitaProduttiva):
    """
    Gestione specifica per Pesche IGP.
    LOGICA DECISIONALE: Monitoraggio delle Sequenze temporali (Giugno vs Settembre)
    e verifica dei requisiti di qualità (Disciplinare IGP).
    """
    def __init__(self, codice, ettari):
        super().__init__(codice, ettari, "Pesche Leonforte IGP")

    def elabora_scenario(self):
        # 1. Stima del carico pendente (Distribuzione Poisson per conteggio frutti)
        carico_pendente = np.random.poisson(MEDIA_FRUTTI_ALBERO)
        totale_frutti = (self.ettari * DENSITA_IMPIANTO) * carico_pendente

        # 2. Sequenza A: Insacchettatura (Costo manodopera preventivo - Giugno)
        h_seq_a = (totale_frutti * SEC_INSACCHETTATURA) / 3600.0

        # 3. Sequenza B: Raccolta e Controllo Qualità (Output commerciale - Settembre)
        peso_target = 0.220 # 220g obiettivo
        # Riduzione peso dovuta allo stress idrico
        peso_effettivo = peso_target * (1.0 - (COEFF_CRISI_IDRICA * 0.35))

        kg_complessivi = totale_frutti * peso_effettivo

        # 4. Algoritmo di conformità IGP
        # Se il peso scende sotto soglia critica, il lotto perde la certificazione
        kg_igp = 0.0
        esito_controllo_qualita = "Conforme"

        if peso_effettivo < 0.165: # Soglia di tolleranza
            esito_controllo_qualita = "NON CONFORME (Sottopeso)"
            kg_igp = kg_complessivi * 0.15 # Solo il 15% passa la selezione
        else:
            kg_igp = kg_complessivi * 0.92 # Il 92% è vendibile come IGP

        self.report_dati = {
            "Codice_Lotto": self.codice,
            "Coltura": self.tipologia,
            "Input_Totale_Kg": round(kg_complessivi, 2),
            "Sequenza_A": "Insacchettamento",
            "Sequenza_B": "Raccolta IGP",
            "Output_A_Kg": 0, # La Sequenza A produce servizio, non merce
            "Output_B_Kg": round(kg_igp, 2),
            "Ore_Seq_A": round(h_seq_a, 2),
            "Ore_Seq_B": 0,
            "Note_Operative": f"{esito_controllo_qualita}. Peso medio: {int(peso_effettivo*1000)}g"
        }
        return self.report_dati


# =============================================================================
# 3. ESECUZIONE DEL SISTEMA (MAIN LOOP)
# =============================================================================

def main():
    print(f"--- SISTEMA DI SIMULAZIONE AGRO-INDUSTRIALE ---")
    print(f"Scenario Caricato: Crisi Idrica livello {COEFF_CRISI_IDRICA}\n")

    # [FASE 1] Inizializzazione del portafoglio campi (Dataset)
    portafoglio_campi = [
        ColturaAgrumi(codice="A-101", ettari=5.0),
        ColturaAgrumi(codice="A-102", ettari=3.5),
        ColturaOlivicola(codice="O-201", ettari=4.0),
        ColturaOlivicola(codice="O-202", ettari=2.0),
        ColturaPescheTardive(codice="P-301", ettari=1.5)
    ]

    database_risultati = []

    # [FASE 2] Elaborazione Batch
    for campo in portafoglio_campi:
        # Polimorfismo: ogni oggetto esegue la propria logica specifica
        dati = campo.elabora_scenario()
        database_risultati.append(dati)

    # [FASE 3] Aggregazione e Reporting (Business Intelligence)
    df_report = pd.DataFrame(database_risultati)

    # Definizione colonne per la vista manageriale (USANDO "SEQUENZA")
    colonne_view = ["Codice_Lotto", "Coltura", "Input_Totale_Kg",
                    "Sequenza_A", "Output_A_Kg", "Ore_Seq_A",
                    "Sequenza_B", "Output_B_Kg", "Ore_Seq_B",
                    "Note_Operative"]

    df_final = df_report[colonne_view]

    # Visualizzazione Tabellare
    print("\n[REPORT ANALITICO DI PRODUZIONE]")
    try:
        display(df_final) # Comando specifico per ambienti Notebook
    except:
        print(df_final.to_string(index=False))

    # Creazione Pivot Table per totali
    print("\n[SINTESI FABBISOGNO ORE LAVORO]")
    pivot_ore = df_report.groupby("Coltura")[["Ore_Seq_A", "Ore_Seq_B"]].sum()
    print(pivot_ore)

    # [FASE 4] Export Dati per ERP
    nome_file = "export_dati_produzione_v2.csv"
    try:
        df_final.to_csv(nome_file, index=False, sep=';')
        print(f"\n[SUCCESS] File generato correttamente: {nome_file}")
    except Exception as e:
        print(f"\n[ERROR] Errore durante il salvataggio: {e}")

if __name__ == "__main__":
    main()